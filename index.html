<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>PlanSift</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìÑ</text></svg>">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PDF.js for rendering PDFs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
    </script>
    
    <!-- PDF-Lib for creating new PDFs -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f1f5f9; /* slate-100 */
        }
        .page-canvas {
            border: 1px solid #cbd5e1; /* slate-300 */
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .page-wrapper {
            position: relative;
            padding-top: 1.5rem;
        }
        .remove-page-btn {
            position: absolute;
            top: 0;
            right: 0;
        }
        /* Custom styles for notifications and modals */
        #notification-container {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .notification {
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            color: white;
            font-weight: 600;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            transform: translateX(120%);
            transition: transform 0.3s ease-in-out;
        }
        .notification.show {
            transform: translateX(0);
        }
        .notification.success { background-color: #16a34a; /* green-600 */ }
        .notification.error { background-color: #dc2626; /* red-600 */ }

        /* Styles for the magnifier popover */
        #magnifier-popover {
            /* Position is now set dynamically via JS */
            z-index: 200;
            background-color: white;
            border: 1px solid #94a3b8; /* slate-400 */
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            pointer-events: none;
            padding: 0.5rem;
        }

        #magnifier-popover canvas {
            display: block;
            max-width: 80vw;
            max-height: 80vh;
            width: auto;
            height: auto;
        }

        /* Styles for the Index Parser Modal */
        #index-canvas-wrapper {
            display: flex;
            align-items: flex-start; 
        }
        #index-parser-canvas {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid #ccc;
            cursor: crosshair;
        }
        
        /* Drag and Drop Area Styling */
        .dragover {
            border-color: #3b82f6; /* blue-500 */
            background-color: #eff6ff; /* blue-50 */
        }
    </style>
</head>
<body class="text-slate-800">
    <!-- Main Application Container -->
    <div class="container mx-auto p-4 md:p-8 max-w-4xl">

        <header class="bg-white p-6 rounded-lg shadow-md mb-8">
            <h1 class="text-3xl font-bold text-slate-700">PlanSift</h1>
            <p class="text-slate-500 mt-1">Find pages and manage search groups.</p>
        </header>

        <!-- Control Panel -->
        <div class="bg-white p-6 rounded-lg shadow-md mb-8">
            <!-- 1. PDF File Input -->
            <div class="mb-6">
                <label class="block text-lg font-semibold text-slate-600 mb-2">1. Open a PDF File</label>
                
                <!-- Drag and Drop Zone -->
                <div id="drop-zone" class="border-2 border-dashed border-slate-300 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 transition-colors">
                    <div class="flex flex-col items-center justify-center pointer-events-none">
                        <svg class="w-12 h-12 text-slate-400 mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m.75 12 3 3m0 0 3-3m-3 3v-6m-1.5-9H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z" />
                        </svg>
                        
                        <p class="text-slate-500">Drag & drop your PDF here, or</p>
        
                        <label for="file-input"
                          class="mt-2 text-blue-600 font-semibold hover:underline cursor-pointer pointer-events-auto">
                          click to select a file
                        </label>
                        
                        <input id="file-input" type="file" accept="application/pdf"
                          class="sr-only" />
                    </div>
                </div>

                <div id="file-info" class="mt-2 text-sm text-slate-600">No file selected.</div>
                <div class="mt-4">
                    <button id="parse-index-btn" class="hidden bg-indigo-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-indigo-600 transition duration-300 disabled:bg-slate-400 disabled:cursor-not-allowed">
                        Select & Parse Index
                    </button>
                </div>
            </div>

            <!-- 2. Search Terms Input & Action -->
            <div class="mb-4">
                <label for="search-terms-input" class="block text-lg font-semibold text-slate-600 mb-2">2. Enter Search Terms & Find Pages</label>
                <div class="flex items-start space-x-2">
                    <textarea id="search-terms-input" rows="3" class="flex-grow p-3 border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" placeholder="e.g. P.001, P.002, PIPE LEGEND"></textarea>
                    <button id="run-search-btn" class="flex-shrink-0 bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 transition duration-300 flex items-center justify-center text-lg disabled:bg-slate-400 disabled:cursor-not-allowed h-full">
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                        Find
                    </button>
                </div>
                <p class="text-xs text-slate-500 mt-1">Separate terms with a comma. Press Enter to search (Shift+Enter for a new line).</p>
            </div>
            
            <!-- 3. Search Groups -->
            <div class="border-t border-slate-200 pt-4 mt-6">
                 <label class="block text-lg font-semibold text-slate-600 mb-2">3. Manage Search Groups</label>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                         <div>
                             <label for="search-groups-dropdown" class="text-sm font-medium text-slate-600">Load a saved group:</label>
                             <div class="flex items-center space-x-2 mt-1">
                                 <select id="search-groups-dropdown" class="w-full p-2 border border-slate-300 rounded-md bg-white"></select>
                                 <button id="load-group-btn" title="Load Selected Group" class="p-2 bg-slate-200 hover:bg-slate-300 rounded-md">
                                      <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 6.75 12 3m0 0 3.75 3.75M12 3v18" /></svg>
                                 </button>
                                 <button id="delete-group-btn" title="Delete Selected Group" class="p-2 bg-red-100 hover:bg-red-200 text-red-600 rounded-md"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                             </div>
                         </div>
                         <div>
                             <label for="new-group-name" class="text-sm font-medium text-slate-600">Save current search as a group:</label>
                             <div class="flex items-center space-x-2 mt-1">
                                 <input type="text" id="new-group-name" placeholder="Group Name" class="w-full p-2 border border-slate-300 rounded-md">
                                 <button id="save-group-btn" title="Save Current Terms" class="p-2 bg-green-500 hover:bg-green-600 text-white rounded-md"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path></svg></button>
                             </div>
                         </div>
                 </div>
            </div>
        </div>

        <!-- Parsed Index Section (Initially Hidden) -->
        <div id="parsed-index-container" class="hidden bg-white p-6 rounded-lg shadow-md mb-8">
            <div class="flex justify-between items-center border-b pb-3 mb-4">
                <h2 class="text-2xl font-bold text-slate-700">Parsed Index</h2>
                <div class="flex items-center space-x-4">
                    <div class="flex items-center">
                        <input id="select-all-index-checkbox" type="checkbox" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                        <label for="select-all-index-checkbox" class="ml-2 text-sm font-medium text-slate-700">Select All</label>
                    </div>
                    <button id="add-selected-index-btn" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300 flex items-center">
                        Add Selected to Results
                    </button>
                </div>
            </div>
            <div id="parsed-index-output" class="space-y-2 max-h-96 overflow-y-auto">
                <p class="text-slate-500">Select an area from the PDF to parse an index.</p>
            </div>
        </div>

        <!-- Results Section -->
        <div id="results-container" class="bg-white p-6 rounded-lg shadow-md">
             <div class="flex justify-between items-center border-b pb-3 mb-4">
                   <h2 class="text-2xl font-bold text-slate-700">Results</h2>
                   <button id="open-pdf-btn" class="hidden bg-green-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-300 flex items-center">
                         <svg class="w-5 h-5 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25" /></svg>
                         Open Filtered PDF
                   </button>
             </div>
               <div id="results-summary"></div>
               <!-- Page Modifiers -->
               <div id="page-modifiers-container" class="hidden mt-4 pt-4 border-t border-slate-200">
                    <h3 class="text-lg font-semibold text-slate-600 mb-2">Add or Remove Pages</h3>
                    <p class="text-xs text-slate-500 mb-2">Use formats like "5", "1-10", or "2, 5-7, 12".</p>
                    <div class="flex items-center space-x-2">
                        <input type="text" id="multi-page-input" placeholder="e.g., 1-5, 8, 11-13" class="w-full p-2 border border-slate-300 rounded-md">
                        <button id="add-pages-btn" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-md font-semibold flex-shrink-0">Add</button>
                        <button id="remove-pages-btn" class="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-md font-semibold flex-shrink-0">Remove</button>
                    </div>
                </div>
               <div id="results-output" class="flex overflow-x-auto space-x-6 p-4 bg-slate-50 rounded-lg mt-6">
                     <p class="w-full px-2 col-span-full">Search results will appear here.</p>
               </div>
        </div>
    </div>
    
    <!-- UI Overlays: Loading, Confirmation, Notifications, Index Parser -->
    <div id="loading-modal" class="hidden fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-white p-5 rounded-lg flex items-center shadow-xl">
            <svg class="w-8 h-8 animate-spin text-blue-600 mr-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
            <span id="loading-text" class="text-lg font-medium text-gray-700">Searching...</span>
        </div>
    </div>

    <div id="notification-container"></div>

    <div id="confirmation-modal" class="hidden fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
            <h3 id="confirmation-title" class="text-lg font-bold text-slate-800 mb-4">Are you sure?</h3>
            <div class="flex justify-end space-x-3">
                <button id="confirm-btn-no" class="px-4 py-2 bg-slate-200 hover:bg-slate-300 rounded-md font-semibold">No</button>
                <button id="confirm-btn-yes" class="px-4 py-2 bg-red-600 text-white hover:bg-red-700 rounded-md font-semibold">Yes</button>
            </div>
        </div>
    </div>

    <div id="index-parser-modal" class="hidden fixed inset-0 bg-gray-800 bg-opacity-75 flex flex-col items-center justify-center z-[60] p-4">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-6xl h-full flex flex-col">
            <!-- Header -->
            <div class="p-4 border-b flex justify-between items-center flex-shrink-0">
                <h3 class="text-xl font-bold text-slate-800">Select Index Area</h3>
                <div class="flex items-center space-x-4 flex-wrap">
                    <div class="flex items-center space-x-2">
                        <button id="index-prev-page" class="p-2 bg-slate-200 hover:bg-slate-300 rounded-md">&lt;</button>
                        <span>Page <input type="number" id="index-page-num" class="w-16 text-center border rounded-md p-1"> of <span id="index-page-count">0</span></span>
                        <button id="index-next-page" class="p-2 bg-slate-200 hover:bg-slate-300 rounded-md">&gt;</button>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button id="zoom-out-btn" title="Zoom Out" class="p-2 bg-slate-200 hover:bg-slate-300 rounded-md">
                             <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM13.5 10.5h-6" /></svg>
                        </button>
                        <span id="zoom-display" class="font-mono text-sm text-slate-600 w-12 text-center">100%</span>
                        <button id="zoom-in-btn" title="Zoom In" class="p-2 bg-slate-200 hover:bg-slate-300 rounded-md">
                             <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6" /></svg>
                        </button>
                        <button id="zoom-fit-btn" title="Fit to Width" class="p-2 bg-slate-200 hover:bg-slate-300 rounded-md">
                             <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M20.25 20.25v-4.5m0 4.5h-4.5m4.5 0L15 15" /></svg>
                        </button>
                    </div>
                    <button id="parse-selection-btn" class="px-4 py-2 bg-green-600 text-white hover:bg-green-700 rounded-md font-semibold disabled:bg-slate-400" disabled>Parse Selection</button>
                    <button id="cancel-index-parser-btn" class="px-4 py-2 bg-slate-200 hover:bg-slate-300 rounded-md font-semibold">Cancel</button>
                </div>
            </div>
            <!-- Content -->
            <div id="index-canvas-wrapper" class="flex-grow p-4 overflow-auto bg-slate-100 relative">
                <div class="relative">
                    <canvas id="index-parser-canvas"></canvas>
                    <div id="selection-box" class="absolute border-2 border-dashed border-blue-500 bg-blue-500 bg-opacity-20 pointer-events-none" style="display: none;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Payment Modal -->
    <div id="payment-modal" class="hidden fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto">
            <h3 class="text-2xl font-bold text-slate-800 mb-4">üîç Choose Your Plan</h3>
            
            <!-- Email collection if needed -->
            <div id="payment-email-section" class="hidden mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                <p class="text-sm text-slate-600 mb-2">Enter your email to continue:</p>
                <input type="email" id="payment-email-input" placeholder="your@email.com" 
                    class="w-full p-2 border border-slate-300 rounded-md">
            </div>
    
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                <!-- Pay as you go -->
                <div class="border border-slate-200 rounded-lg p-4">
                    <h4 class="font-bold text-lg mb-2">Single File</h4>
                    <div class="text-3xl font-bold text-blue-600 mb-3">$1</div>
                    <ul class="text-sm text-slate-600 space-y-2 mb-4">
                        <li>‚úì Current file only</li>
                        <li>‚úì Unlimited searches</li>
                        <li>‚úì 24-hour access</li>
                    </ul>
                    <button class="w-full bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition">
                        Unlock This File
                    </button>
                </div>
    
                <!-- Most popular -->
                <div class="border-2 border-green-500 rounded-lg p-4 relative">
                    <div class="absolute -top-3 left-1/2 transform -translate-x-1/2 bg-green-500 text-white px-3 py-1 rounded-full text-xs font-bold">
                        BEST VALUE
                    </div>
                    <h4 class="font-bold text-lg mb-2">Bundle Pack</h4>
                    <div class="text-3xl font-bold text-green-600 mb-1">$9</div>
                    <div class="text-sm text-slate-500 line-through mb-2">$20 value</div>
                    <ul class="text-sm text-slate-600 space-y-2 mb-4">
                        <li>‚úì 20 files</li>
                        <li>‚úì Never expires</li>
                        <li>‚úì Use anytime</li>
                        <li class="font-semibold text-green-600">Save 55%!</li>
                    </ul>
                    <button class="w-full bg-green-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-green-700 transition">
                        Get Bundle Pack
                    </button>
                </div>
    
                <!-- Monthly -->
                <div class="border border-slate-200 rounded-lg p-4">
                    <h4 class="font-bold text-lg mb-2">Monthly Pro</h4>
                    <div class="text-3xl font-bold text-purple-600 mb-1">$19</div>
                    <div class="text-sm text-slate-500 mb-2">/month</div>
                    <ul class="text-sm text-slate-600 space-y-2 mb-4">
                        <li>‚úì Unlimited files</li>
                        <li>‚úì Priority support</li>
                        <li>‚úì Bulk processing</li>
                        <li>‚úì Cancel anytime</li>
                    </ul>
                    <button class="w-full bg-purple-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-purple-700 transition">
                        Go Pro Monthly
                    </button>
                </div>
            </div>
    
            <button id="close-payment-modal-btn" class="w-full text-slate-500 hover:text-slate-700 font-medium">
                Maybe Later
            </button>
        </div>
    </div>
    
    <!-- Email Capture Modal -->
    <div id="email-modal" class="hidden fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-md">
            <h3 class="text-2xl font-bold text-slate-800 mb-4">Get 2 More Free Searches</h3>
            <p class="text-slate-600 mb-6">Enter your email to continue with 2 additional free searches.</p>
            
            <input type="email" id="email-input" placeholder="your@email.com" class="w-full p-3 border border-slate-300 rounded-lg mb-4 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            
            <button id="submit-email-btn" class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 transition duration-300 mb-3">
                Continue Free
            </button>
            
            <button id="close-email-modal-btn" class="w-full text-slate-500 hover:text-slate-700 font-medium">
                Cancel
            </button>
        </div>
    </div>
    
    <!-- Main Application Logic -->
    <script type="module">
        // --- DOM Element References ---
        const fileInput = document.getElementById('file-input');
        const dropZone = document.getElementById('drop-zone');
        const fileInfo = document.getElementById('file-info');
        const searchTermsInput = document.getElementById('search-terms-input');
        const runSearchBtn = document.getElementById('run-search-btn');
        const resultsSummary = document.getElementById('results-summary');
        const resultsOutput = document.getElementById('results-output');
        const openPdfBtn = document.getElementById('open-pdf-btn');
        const loadingModal = document.getElementById('loading-modal');
        const loadingText = document.getElementById('loading-text');
        const searchGroupsDropdown = document.getElementById('search-groups-dropdown');
        const newGroupNameInput = document.getElementById('new-group-name');
        const saveGroupBtn = document.getElementById('save-group-btn');
        const loadGroupBtn = document.getElementById('load-group-btn');
        const deleteGroupBtn = document.getElementById('delete-group-btn');
        const pageModifiersContainer = document.getElementById('page-modifiers-container');
        const multiPageInput = document.getElementById('multi-page-input');
        const addPagesBtn = document.getElementById('add-pages-btn');
        const removePagesBtn = document.getElementById('remove-pages-btn');
        const notificationContainer = document.getElementById('notification-container');
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmationTitle = document.getElementById('confirmation-title');
        const confirmBtnYes = document.getElementById('confirm-btn-yes');
        const confirmBtnNo = document.getElementById('confirm-btn-no');
        
        // Index Parser DOM Elements
        const parseIndexBtn = document.getElementById('parse-index-btn');
        const indexParserModal = document.getElementById('index-parser-modal');
        const indexCanvasWrapper = document.getElementById('index-canvas-wrapper');
        const indexParserCanvas = document.getElementById('index-parser-canvas');
        const selectionBox = document.getElementById('selection-box');
        const indexPrevPageBtn = document.getElementById('index-prev-page');
        const indexNextPageBtn = document.getElementById('index-next-page');
        const indexPageNumInput = document.getElementById('index-page-num');
        const indexPageCount = document.getElementById('index-page-count');
        const parseSelectionBtn = document.getElementById('parse-selection-btn');
        const cancelIndexParserBtn = document.getElementById('cancel-index-parser-btn');
        const parsedIndexContainer = document.getElementById('parsed-index-container');
        const parsedIndexOutput = document.getElementById('parsed-index-output');
        const addSelectedIndexBtn = document.getElementById('add-selected-index-btn');
        const selectAllIndexCheckbox = document.getElementById('select-all-index-checkbox');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomFitBtn = document.getElementById('zoom-fit-btn');
        const zoomDisplay = document.getElementById('zoom-display');
        
        // Payment DOM Elements
        const paymentModal = document.getElementById('payment-modal');
        const emailModal = document.getElementById('email-modal');
        const closePaymentModalBtn = document.getElementById('close-payment-modal-btn');
        const submitEmailBtn = document.getElementById('submit-email-btn');
        const closeEmailModalBtn = document.getElementById('close-email-modal-btn');
        const unlockFileBtn = document.getElementById('unlock-file-btn');
        const emailInput = document.getElementById('email-input');
        
        // --- Application State ---
        let currentPdf = null;
        let currentFileBuffer = null;
        let matchedPageNumbers = [];
        let searchGroups = [];
        const STORAGE_KEY = 'plansift-search-groups';
        
        // Payment State
        let filesProcessed = 0;
        let userEmail = null;
        let hasUnlockedCurrentFile = false;
        const FREE_FILES = 2; // Free files without email
        const FREE_FILES_WITH_EMAIL = 5; // Free files with email
        const STRIPE_PAYMENT_LINK = 'https://buy.stripe.com/test_5kQ3cu2Reg5wgqE6LD0gw00';

        // --- Analytics Tracking ---
        const UserTracking = {
            sessionId: Date.now().toString(),
            events: [],
            
            track(eventName, data = {}) {
                const event = {
                    event: eventName,
                    timestamp: new Date().toISOString(),
                    sessionId: this.sessionId,
                    email: userEmail || 'not_collected',
                    filesProcessed: filesProcessed,
                    ...data
                };
                
                this.events.push(event);
                console.log('Track:', eventName, data);
                
                // Send to Google Sheets
                this.sendToBackend(event);
            },
            
            sendToBackend(event) {
                // Replace with your actual Apps Script URL
                const scriptUrl = 'YOUR_APPS_SCRIPT_URL_HERE';
                
                fetch(scriptUrl, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: {'Content-Type': 'text/plain'},
                    body: JSON.stringify(event)
                }).catch(err => console.log('Tracking error:', err));
            }
        };
        
        // --- Payment & File Limit Functions ---
        function checkFileLimit() {
            console.log("=== checkFileLimit ===");
            console.log("filesProcessed:", filesProcessed);
            console.log("userEmail:", userEmail);
            
            if (userEmail) {
                console.log(`Has email: ${filesProcessed} < ${FREE_FILES_WITH_EMAIL}`);
                return filesProcessed < FREE_FILES_WITH_EMAIL;
            } else {
                console.log(`No email: ${filesProcessed} < ${FREE_FILES}`);
                return filesProcessed < FREE_FILES;
            }
        }
        
        function showEmailModal() {
            console.log("Showing email modal");
            emailModal.classList.remove('hidden');
        }
        
        function closeEmailModal() {
            console.log("Closing email modal");
            emailModal.classList.add('hidden');
        }
        
        function showPaymentModal() {
            // If no email yet, check first
            if (!userEmail) {
                UserTracking.track('payment_modal_shown_no_email', {
                    filesProcessed: filesProcessed
                });
            } else {
                UserTracking.track('payment_modal_shown', {
                    hasEmail: true,
                    filesProcessed: filesProcessed
                });
            }
            
            console.log("Showing payment modal");
            unlockFileBtn.href = 'https://buy.stripe.com/test_5kQ3cu2Reg5wgqE6LD0gw00';
            paymentModal.classList.remove('hidden');
        }
        
        function closePaymentModal() {
            console.log("Closing payment modal");
            paymentModal.classList.add('hidden');
        }
        
        async function handleEmailSubmit() {
            const email = emailInput.value.trim();

            if (!email || !email.includes('@')) {
                UserTracking.track('email_validation_failed');
                showNotification('Please enter a valid email address.', 'error');
                return;
            }
    
            UserTracking.track('email_submitted', { email: email });
        
            // First, save locally regardless of Apps Script success
            userEmail = email;
            localStorage.setItem('plansift-user-email', email);
            
            // Try to save to Google Sheets (but don't block on failure)
            try {
                // Use URL parameters as a fallback for CORS issues
                const scriptUrl = 'https://script.google.com/macros/s/AKfycbybBpGmLa42qunUqQNEQZkwlWiVkdcMupxVi-yCJvqCwsmopZJ5HUzOyupis4nVg4GA/exec';
                const params = new URLSearchParams({
                    email: email,
                    timestamp: new Date().toISOString(),
                    files_processed: filesProcessed.toString(),
                    event: 'email_submitted'
                });
                
                // Try POST first
                fetch(scriptUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        email: email,
                        timestamp: new Date().toISOString(),
                        files_processed: filesProcessed
                    })
                }).catch(err => {
                    // If POST fails, try GET with parameters (less ideal but works)
                    console.log('POST failed, trying GET fallback');
                    return fetch(`${scriptUrl}?${params.toString()}`, {
                        method: 'GET',
                        mode: 'no-cors'
                    });
                });
                
                console.log('Email submission attempted');
            } catch (error) {
                console.error('Error saving email:', error);
                // Continue anyway - don't block the user
            }
            
            closeEmailModal();
            
            const remainingFiles = FREE_FILES_WITH_EMAIL - filesProcessed;
            showNotification(`Thanks! You can now process ${remainingFiles} more file${remainingFiles !== 1 ? 's' : ''} for free.`, 'success');
            
            continueFileLoad();
        }
        
        function loadUserEmail() {
            const savedEmail = localStorage.getItem('plansift-user-email');
            if (savedEmail) {
                userEmail = savedEmail;
                console.log("Loaded saved email:", userEmail);
            }
            
            // Also load files processed count
            const savedCount = localStorage.getItem('plansift-files-processed');
            if (savedCount) {
                filesProcessed = parseInt(savedCount, 10);
                console.log("Loaded files processed:", filesProcessed);
            }
        }
        
        function incrementFileCount() {
            filesProcessed++;
            localStorage.setItem('plansift-files-processed', filesProcessed.toString());
            console.log("Files processed:", filesProcessed);
        }
        
        // Index Parser State
        let indexParserState = {
            pdf: null,
            currentPageNum: 1,
            totalPages: 0,
            isSelecting: false,
            selectionStart: { x: 0, y: 0 },
            selectionRect: { x: 0, y: 0, w: 0, h: 0 },
            currentRenderedPage: null,
            currentViewport: null,
            currentScale: 'auto',
        };
        
        // --- LocalStorage Functions ---
        function loadGroupsFromStorage() {
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                searchGroups = stored ? JSON.parse(stored) : [];
                renderSearchGroupsDropdown();
            } catch (error) {
                console.error("Error loading groups from storage:", error);
                searchGroups = [];
            }
        }
        
        function saveGroupsToStorage() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(searchGroups));
            } catch (error) {
                console.error("Error saving groups to storage:", error);
                showNotification("Could not save groups.", "error");
            }
        }
        
        function saveSearchGroup() {
            const name = newGroupNameInput.value.trim();
            const terms = searchTermsInput.value.trim();
            if (!name) return showNotification("Please enter a name for the group.", "error");
            if (!terms) return showNotification("Please enter search terms to save.", "error");
        
            const existingIndex = searchGroups.findIndex(g => g.name === name);
            if (existingIndex !== -1) {
                searchGroups[existingIndex].terms = terms;
                showNotification(`Group "${name}" updated.`, "success");
            } else {
                searchGroups.push({ id: Date.now().toString(), name, terms });
                showNotification(`Group "${name}" saved.`, "success");
            }
        
            saveGroupsToStorage();
            renderSearchGroupsDropdown();
            newGroupNameInput.value = '';
        }
        
        function loadSearchGroup() {
            const selectedId = searchGroupsDropdown.value;
            const selectedGroup = searchGroups.find(g => g.id === selectedId);
            if (selectedGroup) {
                searchTermsInput.value = selectedGroup.terms;
            }
        }
        
        function deleteSearchGroup() {
            const selectedId = searchGroupsDropdown.value;
            if (!selectedId) return;
        
            const selectedGroup = searchGroups.find(g => g.id === selectedId);
        
            showConfirmation(`Delete the group "${selectedGroup.name}"?`, () => {
                searchGroups = searchGroups.filter(g => g.id !== selectedId);
                saveGroupsToStorage();
                renderSearchGroupsDropdown();
                showNotification(`Group "${selectedGroup.name}" deleted.`, "success");
            });
        }
        
        function renderSearchGroupsDropdown() {
            const selectedValue = searchGroupsDropdown.value;
            searchGroupsDropdown.innerHTML = '<option value="">-- Select a Group --</option>';
            const sortedGroups = [...searchGroups].sort((a, b) => a.name.localeCompare(b.name));
            for (const group of sortedGroups) {
                const option = document.createElement('option');
                option.value = group.id;
                option.textContent = group.name;
                searchGroupsDropdown.appendChild(option);
            }
            searchGroupsDropdown.value = selectedValue;
        }
        
        // --- Core Application Logic ---
        let pendingFile = null;

        async function loadFile(file) {
            UserTracking.track('file_selected', { fileName: file?.name });
            runSearchBtn.disabled = true;
            parseIndexBtn.classList.add('hidden');
        
            if (!file || file.type !== 'application/pdf') {
                showNotification('Please select a valid PDF file.', 'error');
                fileInfo.textContent = 'Please select a valid PDF file.';
                currentPdf = null;
                return;
            }

            if (!canProcess) {
                UserTracking.track('file_limit_reached');
        
                if (!userEmail) {
                    UserTracking.track('email_modal_shown');
                    showEmailModal();
                } else {
                    UserTracking.track('payment_modal_shown');
                    showPaymentModal();
                }
                return;
            }
            
            // ALWAYS check for email first if we don't have one
            if (!userEmail && filesProcessed >= FREE_FILES) {
                console.log("No email collected yet - showing email modal first");
                pendingFile = file;
                showEmailModal();
                return;
            }
            
            // Then check file limits
            const canProcess = checkFileLimit();
            console.log("Can process file?", canProcess);
            
            if (!canProcess) {
                console.log("FILE LIMIT REACHED!");
                pendingFile = file;
                showPaymentModal();
                return;
            }
            
            continueFileLoad(file);
        }
        
        async function continueFileLoad(file = null) {
            const fileToLoad = file || pendingFile;
            if (!fileToLoad) return;
            
            pendingFile = null;
            
            fileInfo.textContent = `File: ${fileToLoad.name}`;
            const fileReader = new FileReader();
            fileReader.onload = async (e) => {
                setLoading(true, "Loading PDF...");
                try {
                    currentFileBuffer = e.target.result;
                    const typedarray = new Uint8Array(e.target.result);
                    currentPdf = await pdfjsLib.getDocument({ data: typedarray }).promise;
                    console.log("PDF loaded successfully");
                    
                    // INCREMENT FILE COUNT AFTER SUCCESSFUL LOAD
                    incrementFileCount();
                    
                    runSearchBtn.disabled = false;
                    parseIndexBtn.classList.remove('hidden');
                    
                    const remaining = (userEmail ? FREE_FILES_WITH_EMAIL : FREE_FILES) - filesProcessed;
                    if (remaining > 0) {
                        showNotification(`File loaded! ${remaining} free file${remaining !== 1 ? 's' : ''} remaining.`, 'success');
                    }
                } catch (error) {
                    console.error("Error loading PDF:", error);
                    fileInfo.textContent = 'Error: Could not load PDF. Check console for details.';
                    showNotification('Error: Could not load PDF.', 'error');
                    currentPdf = null;
                    currentFileBuffer = null;
                } finally {
                    setLoading(false);
                }
            };
            fileReader.readAsArrayBuffer(fileToLoad);
        }

        function handleFileSelect(e) {
          const [file] = e.target.files || [];
          if (!file) {
            showNotification('No file selected.', 'error');
            return;
          }
          loadFile(file);
        
          // allow selecting the same file again to retrigger change
          e.target.value = '';
        }

        async function runSearch() {
            console.log("=== runSearch called ===");
            
            if (!currentPdf) {
                showNotification('Please select a PDF file first.', 'error');
                return;
            }
        
            const termsText = searchTermsInput.value.trim();
            
            if (!termsText) {
                showNotification('Please enter some search terms.', 'error');
                return;
            }
            
            // NOW you can use it in tracking
            UserTracking.track('search_initiated', { 
                searchTerms: termsText,
                termCount: termsText.split(',').length
            });
            
            const searchTerms = termsText.split(',').map(term => term.trim().toLowerCase().replace(/\s+/g, '')).filter(term => term.length > 0);
            
            if (searchTerms.length === 0) {
                showNotification('Please enter valid search terms.', 'error');
                return;
            }
        
            setLoading(true, "Searching PDF...");
            resultsOutput.innerHTML = ''; 
            resultsSummary.innerHTML = '';
            openPdfBtn.classList.add('hidden'); 
            pageModifiersContainer.classList.add('hidden'); 
            const matchedPages = new Set(); 
        
            for (let i = 1; i <= currentPdf.numPages; i++) {
                setLoading(true, `Searching page ${i} of ${currentPdf.numPages}...`);
                const page = await currentPdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join('').toLowerCase().replace(/\s+/g, '');
        
                const isMatch = searchTerms.some(term => pageText.includes(term));
                if (isMatch) {
                    matchedPages.add(page.pageNumber); 
                }
            }
        
            matchedPageNumbers = Array.from(matchedPages).sort((a,b) => a-b);
            await rerenderAllResults();
            updateResultsSummary();
            setLoading(false);

            UserTracking.track('search_completed', { 
                pagesFound: matchedPageNumbers.length,
                totalPages: currentPdf?.numPages
            });
        }
        
        async function openFilteredPdfInNewTab() {
            UserTracking.track('pdf_exported', { 
                pageCount: matchedPageNumbers.length 
            });
            
            if (!currentFileBuffer || matchedPageNumbers.length === 0) {
                showNotification("No file or pages to open.", "error");
                return;
            }
            
            setLoading(true, "Creating new PDF...");
            try {
                const originalPdfBytes = currentFileBuffer;
                const { PDFDocument } = PDFLib; 
                const pdfDoc = await PDFDocument.load(originalPdfBytes);
                const newPdfDoc = await PDFDocument.create();
        
                const pageIndices = matchedPageNumbers.map(n => n - 1).sort((a, b) => a - b);
                const copiedPages = await newPdfDoc.copyPages(pdfDoc, pageIndices);
                copiedPages.forEach(page => newPdfDoc.addPage(page));
        
                const newPdfBytes = await newPdfDoc.save();
                const blob = new Blob([newPdfBytes], { type: 'application/pdf' });
                const blobUrl = URL.createObjectURL(blob);
                window.open(blobUrl, '_blank');
            } catch (error) {
                console.error("Error creating filtered PDF:", error);
                showNotification("Error creating PDF. Check console.", "error");
            } finally {
                setLoading(false);
            }
        }
        
        // --- UI Rendering Functions ---
        async function renderPage(page, container) {
            const pageNum = page.pageNumber;
            const wrapper = document.createElement('div');
            wrapper.className = 'page-wrapper flex-shrink-0 w-64';
            wrapper.id = `page-wrapper-${pageNum}`;
            wrapper.dataset.pageNumber = pageNum;
        
            const removeBtn = document.createElement('button');
            removeBtn.innerHTML = '&times;';
            removeBtn.className = 'remove-page-btn bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center font-bold hover:bg-red-700 transition-colors z-10';
            removeBtn.title = `Remove page ${pageNum}`;
            removeBtn.onclick = () => removePage(pageNum);
            
            const unscaledViewport = page.getViewport({ scale: 1.0 });
            const containerWidth = 256;
            const scale = (containerWidth / unscaledViewport.width); 
            const viewport = page.getViewport({ scale: scale });
        
            const canvas = document.createElement('canvas');
            canvas.className = 'page-canvas mx-auto'; 
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
        
            const pageTitle = document.createElement('p');
            pageTitle.className = 'text-sm font-bold text-center text-slate-600 mb-1';
            pageTitle.textContent = `Page ${pageNum}`;
        
            wrapper.addEventListener('mouseenter', handleMouseEnter);
            wrapper.addEventListener('mouseleave', handleMouseLeave);
            
            wrapper.appendChild(removeBtn); 
            wrapper.appendChild(pageTitle); 
            wrapper.appendChild(canvas);
            container.appendChild(wrapper);
        
            await page.render({ canvasContext: context, viewport: viewport }).promise;
        }
        
        async function rerenderAllResults() {
            handleMouseLeave();
            resultsOutput.innerHTML = '<p class="w-full px-2">Loading page previews...</p>'; 
            if (matchedPageNumbers.length > 0) {
                resultsOutput.innerHTML = '';
                 for (const pageNum of matchedPageNumbers) {
                       const page = await currentPdf.getPage(pageNum);
                       await renderPage(page, resultsOutput);
                 }
            } else {
                 resultsOutput.innerHTML = '<p class="w-full px-2">No pages found or all pages have been removed.</p>';
            }
        }
        
        function removePage(pageNum) {
            handleMouseLeave();
            const wrapperToRemove = document.getElementById(`page-wrapper-${pageNum}`);
            if (wrapperToRemove) wrapperToRemove.remove();
            matchedPageNumbers = matchedPageNumbers.filter(num => num !== pageNum);
            updateResultsSummary();
        }
        
        function updateResultsSummary() {
            if (matchedPageNumbers.length > 0) {
                 const pageNumbersList = matchedPageNumbers.sort((a, b) => a - b);
                 resultsSummary.innerHTML = `<p class="mb-2 font-semibold">${matchedPageNumbers.length} selected page(s).</p><div class="mb-2 text-sm text-slate-600 break-words">Pages: <strong>${pageNumbersList.join(', ')}</strong></div>`;
                 openPdfBtn.classList.remove('hidden');
                 pageModifiersContainer.classList.remove('hidden'); 
            } else {
                 handleMouseLeave();
                 resultsSummary.innerHTML = '';
                 openPdfBtn.classList.add('hidden');
                 pageModifiersContainer.classList.add('hidden');
                 resultsOutput.innerHTML = '<p class="w-full px-2">No pages found or all pages have been removed.</p>';
            }
        }
        
        // --- Page Adding/Removing Functions ---
        function parsePageString(str) {
            if (!str || typeof str !== 'string') return [];
            
            const pageNumbers = new Set();
            const parts = str.split(',');
        
            for (const part of parts) {
                const trimmedPart = part.trim();
                if (trimmedPart.includes('-')) {
                    const [startStr, endStr] = trimmedPart.split('-');
                    const start = parseInt(startStr, 10);
                    const end = parseInt(endStr, 10);
        
                    if (!isNaN(start) && !isNaN(end) && start <= end) {
                        for (let i = start; i <= end; i++) {
                            pageNumbers.add(i);
                        }
                    } else {
                        console.warn(`Invalid page range found: "${trimmedPart}"`);
                    }
                } else {
                    const pageNum = parseInt(trimmedPart, 10);
                    if (!isNaN(pageNum)) {
                        pageNumbers.add(pageNum);
                    }
                }
            }
            return Array.from(pageNumbers).sort((a, b) => a - b);
        }
        
        async function handleAddPages() {
            if (!currentPdf) return showNotification("Please load a PDF first.", "error");
            const inputString = multiPageInput.value;
            const pagesToAdd = parsePageString(inputString);
        
            if (pagesToAdd.length === 0) return showNotification("Please enter valid pages to add.", "error");
        
            setLoading(true, "Adding pages...");
            const pagesToInclude = new Set(matchedPageNumbers);
            pagesToAdd.forEach(p => {
                if (p > 0 && p <= currentPdf.numPages) {
                    pagesToInclude.add(p);
                } else {
                    showNotification(`Page ${p} is out of bounds (1-${currentPdf.numPages}).`, "error");
                }
            });
        
            matchedPageNumbers = Array.from(pagesToInclude).sort((a, b) => a - b);
            
            await rerenderAllResults();
            updateResultsSummary();
            multiPageInput.value = '';
            setLoading(false);
        }
        
        async function handleRemovePages() {
            if (!currentPdf) return showNotification("Please load a PDF first.", "error");
            const inputString = multiPageInput.value;
            const pagesToRemove = parsePageString(inputString);
        
            if (pagesToRemove.length === 0) return showNotification("Please enter valid pages to remove.", "error");
        
            setLoading(true, "Removing pages...");
            const pagesToRemoveSet = new Set(pagesToRemove);
            matchedPageNumbers = matchedPageNumbers.filter(p => !pagesToRemoveSet.has(p));
            
            await rerenderAllResults();
            updateResultsSummary();
            multiPageInput.value = '';
            setLoading(false);
        }
        
        // --- Index Parser Functions ---
        function openIndexParser() {
            if (!currentPdf) return;
            indexParserState.pdf = currentPdf;
            indexParserState.totalPages = currentPdf.numPages;
            indexParserState.currentPageNum = 1;
            indexParserState.currentScale = 'auto';
            indexPageCount.textContent = indexParserState.totalPages;
            indexPageNumInput.value = 1;
            indexParserModal.classList.remove('hidden');
            renderIndexPage(1);
        }
        
        function closeIndexParser() {
            indexParserModal.classList.add('hidden');
            indexParserCanvas.width = 0;
            indexParserCanvas.height = 0;
            selectionBox.style.display = 'none';
            parseSelectionBtn.disabled = true;
        }
        
        async function renderIndexPage(pageNum) {
            if (!indexParserState.pdf) return;
            setLoading(true, `Loading page ${pageNum}...`);
            try {
                const page = await indexParserState.pdf.getPage(pageNum);
                indexParserState.currentRenderedPage = page;
                
                let scale;
                const unscaledViewport = page.getViewport({ scale: 1.0 });
        
                if (indexParserState.currentScale === 'auto') {
                    const wrapperWidth = indexCanvasWrapper.clientWidth - 40;
                    scale = wrapperWidth / unscaledViewport.width;
                } else {
                    scale = indexParserState.currentScale;
                }
        
                zoomDisplay.textContent = `${Math.round(scale * 100)}%`;
                const viewport = page.getViewport({ scale: scale });
                indexParserState.currentViewport = viewport;
        
                const context = indexParserCanvas.getContext('2d');
                indexParserCanvas.height = viewport.height;
                indexParserCanvas.width = viewport.width;
        
                await page.render({ canvasContext: context, viewport: viewport }).promise;
            } catch (error) {
                console.error(`Failed to render page ${pageNum}:`, error);
                showNotification(`Could not render page ${pageNum}.`, 'error');
            } finally {
                setLoading(false);
            }
        }
        
        function changeIndexPage(delta) {
            let newPageNum = indexParserState.currentPageNum + delta;
            if (newPageNum > 0 && newPageNum <= indexParserState.totalPages) {
                indexParserState.currentPageNum = newPageNum;
                indexPageNumInput.value = newPageNum;
                renderIndexPage(newPageNum);
            }
        }
        
        function goToIndexPage() {
            let newPageNum = parseInt(indexPageNumInput.value, 10);
            if (!isNaN(newPageNum) && newPageNum > 0 && newPageNum <= indexParserState.totalPages) {
                indexParserState.currentPageNum = newPageNum;
                renderIndexPage(newPageNum);
            } else {
                indexPageNumInput.value = indexParserState.currentPageNum;
            }
        }
        
        function handleSelectionStart(e) {
            indexParserState.isSelecting = true;
            indexParserState.selectionStart.x = e.offsetX;
            indexParserState.selectionStart.y = e.offsetY;
            selectionBox.style.left = `${e.offsetX}px`;
            selectionBox.style.top = `${e.offsetY}px`;
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            selectionBox.style.display = 'block';
            parseSelectionBtn.disabled = true;
        }
        
        function handleSelectionMove(e) {
            if (!indexParserState.isSelecting) return;
            const currentX = e.offsetX;
            const currentY = e.offsetY;
        
            const x = Math.min(currentX, indexParserState.selectionStart.x);
            const y = Math.min(currentY, indexParserState.selectionStart.y);
            const width = Math.abs(currentX - indexParserState.selectionStart.x);
            const height = Math.abs(currentY - indexParserState.selectionStart.y);
        
            selectionBox.style.left = `${x}px`;
            selectionBox.style.top = `${y}px`;
            selectionBox.style.width = `${width}px`;
            selectionBox.style.height = `${height}px`;
        }
        
        function handleSelectionEnd(e) {
            indexParserState.isSelecting = false;
            const finalWidth = parseFloat(selectionBox.style.width);
            const finalHeight = parseFloat(selectionBox.style.height);
            if (finalWidth > 5 && finalHeight > 5) {
                parseSelectionBtn.disabled = false;
            } else {
                selectionBox.style.display = 'none';
            }
        }
        
        function getCurrentScale() {
            if (indexParserState.currentScale !== 'auto') {
                return indexParserState.currentScale;
            }
            const page = indexParserState.currentRenderedPage;
            if (!page) return 1.0; 
            const wrapperWidth = indexCanvasWrapper.clientWidth - 40;
            const unscaledViewport = page.getViewport({ scale: 1.0 });
            return wrapperWidth / unscaledViewport.width;
        }
        
        function handleZoomIn() {
            const currentScale = getCurrentScale();
            indexParserState.currentScale = currentScale + 0.25;
            renderIndexPage(indexParserState.currentPageNum);
        }
        
        function handleZoomOut() {
            const currentScale = getCurrentScale();
            indexParserState.currentScale = Math.max(0.1, currentScale - 0.25);
            renderIndexPage(indexParserState.currentPageNum);
        }
        
        function handleZoomFit() {
            indexParserState.currentScale = 'auto';
            renderIndexPage(indexParserState.currentPageNum);
        }
        
        async function findIndexPages(terms, pageToExclude) {
            if (!currentPdf || terms.length === 0) {
                return [];
            }
        
            const foundIndexData = [];
            const termsToFind = new Map(
                terms.map(term => {
                    const cleanedWords = term.toLowerCase().match(/[\w.]+/g) || [];
                    return [term, cleanedWords];
                })
            );
        
            for (let i = 1; i <= currentPdf.numPages; i++) {
                if (i === pageToExclude) {
                    continue;
                }
        
                if (termsToFind.size === 0) {
                    break;
                }
        
                setLoading(true, `Scanning for index terms on page ${i} of ${currentPdf.numPages}...`);
        
                const page = await currentPdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ').toLowerCase();
        
                for (const [originalTerm, searchWords] of termsToFind.entries()) {
                    if (searchWords.length === 0) {
                        termsToFind.delete(originalTerm);
                        continue;
                    }
                    
                    const allWordsFound = searchWords.every(word => pageText.includes(word));
        
                    if (allWordsFound) {
                        foundIndexData.push({ description: originalTerm, pageNum: i });
                        termsToFind.delete(originalTerm);
                    }
                }
            }
        
            if (termsToFind.size > 0) {
                showNotification(`${termsToFind.size} index terms could not be found in the document.`, 'error');
                console.log("Unfound terms:", [...termsToFind.keys()]);
            }
        
            foundIndexData.sort((a, b) => terms.indexOf(a.description) - terms.indexOf(b.description));
        
            return foundIndexData;
        }
        
        async function parseSelectedText() {
            setLoading(true, "Parsing selection...");
            try {
                const page = indexParserState.currentRenderedPage;
                const viewport = indexParserState.currentViewport;
                if (!page || !viewport) {
                    throw new Error("No page or viewport available for parsing.");
                }
                
                const pageToExclude = page.pageNumber;
                
                const rect = {
                    x: parseFloat(selectionBox.style.left),
                    y: parseFloat(selectionBox.style.top),
                    width: parseFloat(selectionBox.style.width),
                    height: parseFloat(selectionBox.style.height)
                };
        
                const startPoint = viewport.convertToPdfPoint(rect.x, rect.y + rect.height);
                const endPoint = viewport.convertToPdfPoint(rect.x + rect.width, rect.y);
                const pdfRect = { x1: startPoint[0], y1: startPoint[1], x2: endPoint[0], y2: endPoint[1] };
        
                const textContent = await page.getTextContent();
                const itemsInBox = textContent.items.filter(item => {
                    const tx = item.transform;
                    const x = tx[4];
                    const y = tx[5];
                    return x >= pdfRect.x1 && x <= pdfRect.x2 && y >= pdfRect.y1 && y <= pdfRect.y2;
                });
        
                itemsInBox.sort((a, b) => {
                    const y1 = a.transform[5];
                    const y2 = b.transform[5];
                    if (Math.abs(y1 - y2) > 2) { 
                        return y2 - y1;
                    }
                    return a.transform[4] - b.transform[4];
                });
        
                let lines = [];
                if (itemsInBox.length > 0) {
                    let currentLine = [itemsInBox[0]];
                    for (let i = 1; i < itemsInBox.length; i++) {
                        if (Math.abs(itemsInBox[i].transform[5] - itemsInBox[i-1].transform[5]) > 2) {
                            lines.push(currentLine.map(i => i.str).join(' '));
                            currentLine = [itemsInBox[i]];
                        } else {
                            currentLine.push(itemsInBox[i]);
                        }
                    }
                    lines.push(currentLine.map(i => i.str).join(' '));
                }
                
                const searchTermsFromIndex = lines.map(line => line.trim().replace(/\s+/g, ' ')).filter(line => line.length > 2);
        
                if (searchTermsFromIndex.length === 0) {
                    showNotification("No text found in the selection to use as search terms.", "error");
                    closeIndexParser();
                    return;
                }
                
                closeIndexParser();
        
                const parsedIndexData = await findIndexPages(searchTermsFromIndex, pageToExclude);
        
                if (parsedIndexData.length > 0) {
                    renderParsedIndex(parsedIndexData);
                    showNotification(`${parsedIndexData.length} index items found in the document.`, 'success');
                } else {
                    showNotification("Could not find any of the selected index items in the document.", "error");
                }
        
            } catch(error) {
                console.error("Error parsing selected text:", error);
                showNotification("Could not parse text from selection.", "error");
            } finally {
                setLoading(false);
            }
        }
        
        function updateSelectAllCheckboxState() {
            const indexCheckboxes = parsedIndexOutput.querySelectorAll('input[type="checkbox"]');
            if (indexCheckboxes.length === 0) {
                selectAllIndexCheckbox.checked = false;
                selectAllIndexCheckbox.indeterminate = false;
                return;
            }
        
            const total = indexCheckboxes.length;
            const checkedCount = Array.from(indexCheckboxes).filter(cb => cb.checked).length;
        
            if (checkedCount === 0) {
                selectAllIndexCheckbox.checked = false;
                selectAllIndexCheckbox.indeterminate = false;
            } else if (checkedCount === total) {
                selectAllIndexCheckbox.checked = true;
                selectAllIndexCheckbox.indeterminate = false;
            } else {
                selectAllIndexCheckbox.checked = false;
                selectAllIndexCheckbox.indeterminate = true;
            }
        }
        
        function renderParsedIndex(indexData) {
            parsedIndexOutput.innerHTML = ''; 
        
            if (indexData.length === 0) {
                parsedIndexOutput.innerHTML = '<p class="text-slate-500">No index data to display.</p>';
                parsedIndexContainer.classList.add('hidden');
                return;
            }
        
            indexData.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'p-2 rounded-md hover:bg-slate-100 flex items-center';
        
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `index-item-${index}`;
                checkbox.className = 'mr-3 h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500';
                checkbox.dataset.pageNum = item.pageNum;
                checkbox.addEventListener('change', updateSelectAllCheckboxState);
        
                const label = document.createElement('label');
                label.htmlFor = `index-item-${index}`;
                label.className = 'flex-grow cursor-pointer';
                label.textContent = item.description;
        
                const pageNumSpan = document.createElement('span');
                pageNumSpan.className = 'ml-4 font-mono text-sm text-slate-500 bg-slate-200 px-2 py-1 rounded';
                pageNumSpan.textContent = `Pg. ${item.pageNum}`;
        
                div.appendChild(checkbox);
                div.appendChild(label);
                div.appendChild(pageNumSpan);
                parsedIndexOutput.appendChild(div);
            });
        
            parsedIndexContainer.classList.remove('hidden');
            updateSelectAllCheckboxState();
        }
        
        async function addSelectedIndexPages() {
            const checkedBoxes = document.querySelectorAll('#parsed-index-output input[type="checkbox"]:checked');
        
            if (checkedBoxes.length === 0) {
                showNotification("No index items selected.", "error");
                return;
            }
        
            setLoading(true, "Adding selected pages...");
            const pagesToAdd = new Set(matchedPageNumbers);
            checkedBoxes.forEach(box => {
                const pageNum = parseInt(box.dataset.pageNum, 10);
                if (!isNaN(pageNum)) {
                    pagesToAdd.add(pageNum);
                }
            });
        
            matchedPageNumbers = Array.from(pagesToAdd).sort((a, b) => a - b);
        
            await rerenderAllResults();
            updateResultsSummary();
            setLoading(false);
            showNotification(`${checkedBoxes.length} page(s) added to results.`, "success");
        }
        
        // --- Utility Functions (UI Helpers) ---
        function setLoading(isLoading, text = "Loading...") {
            loadingText.textContent = text;
            loadingModal.classList.toggle('hidden', !isLoading);
        }
        
        function showNotification(message, type = 'success') {
            const notif = document.createElement('div');
            notif.className = `notification ${type}`;
            notif.textContent = message;
            notificationContainer.appendChild(notif);
        
            setTimeout(() => notif.classList.add('show'), 10);
            setTimeout(() => {
                notif.classList.remove('show');
                notif.addEventListener('transitionend', () => notif.remove());
            }, 3000);
        }
        
        function showConfirmation(message, onConfirm) {
            confirmationTitle.textContent = message;
            confirmationModal.classList.remove('hidden');
        
            const confirmHandler = () => {
                onConfirm();
                cleanup();
            };
        
            const cancelHandler = () => {
                cleanup();
            };
            
            function cleanup() {
                confirmationModal.classList.add('hidden');
                confirmBtnYes.removeEventListener('click', confirmHandler);
                confirmBtnNo.removeEventListener('click', cancelHandler);
            }
        
            confirmBtnYes.addEventListener('click', confirmHandler, { once: true });
            confirmBtnNo.addEventListener('click', cancelHandler, { once: true });
        }
        
        // --- Magnifier Functions ---
        function handleMouseLeave(event) {
            const popover = document.getElementById('magnifier-popover');
            if (popover) {
                popover.remove();
            }
        }
        
        async function handleMouseEnter(event) {
            const pageNum = parseInt(event.currentTarget.dataset.pageNumber, 10);
            if (!currentPdf || !pageNum) return;
            
            handleMouseLeave();
            
            const popover = document.createElement('div');
            popover.id = 'magnifier-popover';
            
            const loadingMessage = document.createElement('p');
            loadingMessage.textContent = 'Loading...';
            loadingMessage.className = 'p-4';
            popover.appendChild(loadingMessage);
            document.body.appendChild(popover);
            
            const magnifiedWidth = 1000;
            const page = await currentPdf.getPage(pageNum);
            const unscaledViewport = page.getViewport({ scale: 1.0 });
            const scale = magnifiedWidth / unscaledViewport.width;
            const viewport = page.getViewport({ scale: scale });
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            
            await page.render({ canvasContext: context, viewport: viewport }).promise;
            
            popover.innerHTML = '';
            popover.appendChild(canvas);
        
            const popoverRect = popover.getBoundingClientRect();
            const cursorX = event.clientX;
            const cursorY = event.clientY;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const margin = 10;
        
            let top, left;
        
            if (cursorY < viewportHeight * 0.6) {
                top = cursorY + margin;
            } else {
                top = cursorY - popoverRect.height - margin;
            }
        
            if (cursorX < viewportWidth / .5) {
                left = cursorX + margin;
            } else {
                left = cursorX - popoverRect.width - margin;
            }
            
            if (top < margin) top = margin;
            if (left < margin) left = margin;
            if (top + popoverRect.height > viewportHeight - margin) {
                top = viewportHeight - popoverRect.height - margin;
            }
            if (left + popoverRect.width > viewportWidth - margin) {
                left = viewportWidth - popoverRect.width - margin;
            }
        
            popover.style.position = 'fixed';
            popover.style.top = `${top}px`;
            popover.style.left = `${left}px`;
        }
        
        function handleSelectAllIndex(e) {
            const isChecked = e.target.checked;
            const indexCheckboxes = parsedIndexOutput.querySelectorAll('input[type="checkbox"]');
            indexCheckboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
            });
        }
        
        // --- Initial Application Setup ---
        function init() {
            console.log("=== PlanSift Initializing ===");
            runSearchBtn.disabled = true; 
            fileInput.addEventListener('change', handleFileSelect);
            UserTracking.track('session_start', {
                referrer: document.referrer,
                url: window.location.href,
                userAgent: navigator.userAgent
            });

            searchTermsInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    runSearchBtn.click();
                }
            });
            
            dropZone.addEventListener('dragover', (e) => {
              e.preventDefault();
              e.dataTransfer.dropEffect = 'copy';
              dropZone.classList.add('dragover');
            });
            dropZone.addEventListener('dragleave', (e) => {
              e.preventDefault();
              dropZone.classList.remove('dragover');
            });
            dropZone.addEventListener('drop', (e) => {
              e.preventDefault();
              dropZone.classList.remove('dragover');
              const f = e.dataTransfer.files?.[0];
              if (f) loadFile(f);
              fileInput.value = '';
            });

            
            dropZone.addEventListener('click', (e) => {
              // If the click came from the label (or the input), do nothing.
              if (e.target.closest('label[for="file-input"]') || e.target.id === 'file-input') return;
              fileInput.click();
            });
        
            saveGroupBtn.addEventListener('click', saveSearchGroup);
            loadGroupBtn.addEventListener('click', loadSearchGroup);
            deleteGroupBtn.addEventListener('click', deleteSearchGroup);
            addPagesBtn.addEventListener('click', handleAddPages);
            removePagesBtn.addEventListener('click', handleRemovePages);
            runSearchBtn.addEventListener('click', runSearch);
            openPdfBtn.addEventListener('click', openFilteredPdfInNewTab);
            addSelectedIndexBtn.addEventListener('click', addSelectedIndexPages);
            selectAllIndexCheckbox.addEventListener('change', handleSelectAllIndex);
        
            parseIndexBtn.addEventListener('click', openIndexParser);
            cancelIndexParserBtn.addEventListener('click', closeIndexParser);
            indexPrevPageBtn.addEventListener('click', () => changeIndexPage(-1));
            indexNextPageBtn.addEventListener('click', () => changeIndexPage(1));
            indexPageNumInput.addEventListener('change', goToIndexPage);
            parseSelectionBtn.addEventListener('click', parseSelectedText);
            zoomInBtn.addEventListener('click', handleZoomIn);
            zoomOutBtn.addEventListener('click', handleZoomOut);
            zoomFitBtn.addEventListener('click', handleZoomFit);
            
            indexParserCanvas.parentElement.addEventListener('mousedown', handleSelectionStart);
            indexParserCanvas.parentElement.addEventListener('mousemove', handleSelectionMove);
            indexParserCanvas.parentElement.addEventListener('mouseup', handleSelectionEnd);
        
            // Payment modal event listeners
            closePaymentModalBtn.addEventListener('click', closePaymentModal);
            submitEmailBtn.addEventListener('click', handleEmailSubmit);
            closeEmailModalBtn.addEventListener('click', closeEmailModal);
            
            emailInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleEmailSubmit();
                }
            });
        
            loadGroupsFromStorage();
            loadUserEmail();
        }
            document.addEventListener('DOMContentLoaded', init);
        
</script>
</body>
</html>
